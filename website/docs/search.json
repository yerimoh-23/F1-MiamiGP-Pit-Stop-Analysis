[
  {
    "objectID": "stat244.html",
    "href": "stat244.html",
    "title": "STAT-244-SC",
    "section": "",
    "text": "May 8, 2025\nEonbi Choi, Yerim Oh"
  },
  {
    "objectID": "stat244.html#abstract",
    "href": "stat244.html#abstract",
    "title": "STAT-244-SC",
    "section": "Abstract",
    "text": "Abstract\nThis study employs different regression models to predict when a driver to make a pit stop at during a race, based on the Formula 1 Miami Grand Prix 2024 data. The dataset includes various indicators (32 variables), such as driver details, lap times, pit in/out times, tire information, and track status, for 1111 laps. The aim of this analysis is to estimate pit stop timing based on tire and lap information. The models demonstrate that tire compound, lap number, etc. are significant predictors of pit stop behavior, offering insights into strategic decision-making in race management."
  },
  {
    "objectID": "stat244.html#datasets",
    "href": "stat244.html#datasets",
    "title": "STAT-244-SC",
    "section": "Datasets",
    "text": "Datasets\nThe Formula 1 data used in this study are obtained from the f1dataR R package that accesses Formula 1 data via the FastF1 Python library. The dataset includes lap-by-lap session data from the 2024 Miami Grand Prix and comprise 1111 laps and 32 variables. These variables include driver details, lap times, pit in/out times, tire information, and track status.\nSource: R Package ‘f1dataR’\n\nDescription: https://cran.r-project.org/web/packages/f1dataR/f1dataR.pdf\nData sources: Obtain Formula 1 data via the unofficial API https://www.formula1.com/en/timing/f1-live via the ‘fastf1’ ‘Python’ library https://docs.fastf1.dev/.\nLast accessed date/time: April 28, 2025 16:51 PM\n\n\n\n# A tibble: 6 × 32\n   time driver driver_number lap_time lap_number stint pit_out_time pit_in_time\n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n1 3438. VER    1                 94.3          1     1          NaN         NaN\n2 3531. VER    1                 93.1          2     1          NaN         NaN\n3 3624. VER    1                 93.1          3     1          NaN         NaN\n4 3717. VER    1                 93.5          4     1          NaN         NaN\n5 3810. VER    1                 92.8          5     1          NaN         NaN\n6 3903. VER    1                 92.9          6     1          NaN         NaN\n# ℹ 24 more variables: sector1time &lt;dbl&gt;, sector2time &lt;dbl&gt;, sector3time &lt;dbl&gt;,\n#   sector1session_time &lt;dbl&gt;, sector2session_time &lt;dbl&gt;,\n#   sector3session_time &lt;dbl&gt;, speed_i1 &lt;dbl&gt;, speed_i2 &lt;dbl&gt;, speed_fl &lt;dbl&gt;,\n#   speed_st &lt;dbl&gt;, is_personal_best &lt;list&gt;, compound &lt;chr&gt;, tyre_life &lt;dbl&gt;,\n#   fresh_tyre &lt;lgl&gt;, team &lt;chr&gt;, lap_start_time &lt;dbl&gt;, lap_start_date &lt;dttm&gt;,\n#   track_status &lt;chr&gt;, position &lt;dbl&gt;, deleted &lt;lgl&gt;, deleted_reason &lt;chr&gt;,\n#   fast_f1generated &lt;lgl&gt;, is_accurate &lt;lgl&gt;, session_type &lt;chr&gt;\n\n\n\nVariables\nquantitative variable:\n\nlap_time: recorded time to complete a lap (seconds)\nlap_number: lap number from which the telemetry data was recorded (number of laps)\ntyre_life: number of laps completed on a set of tires (number of laps)\n\ncategorical variable:\n\ncompound: type of tire used (SOFT, MEDIUM, HARD)\npit_in: whether a driver made a pit stop during a lap (binary: 0 = no pit stop, 1 = pit stop occured)\n\n\n\nClean/Rearrange Data\nRearrange data to consist only the variables we are interested in\n\nCheck missing values\n\nData for lap_time are missing 5 values which are less than 0.1% of the entire observation\n\n\nFinalize data we are going to use\n\n\n# A tibble: 6 × 5\n  lap_time lap_number compound tyre_life pit_in\n     &lt;dbl&gt;      &lt;dbl&gt; &lt;fct&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1     94.3          1 MEDIUM           1      0\n2     93.1          2 MEDIUM           2      0\n3     93.1          3 MEDIUM           3      0\n4     93.5          4 MEDIUM           4      0\n5     92.8          5 MEDIUM           5      0\n6     92.9          6 MEDIUM           6      0\n\n\n\n\nWhy certain data points are missing\nOut of 5 missing lap time records four records have a track status code of 41. However, no description of this code value is provided in the API. Thus, we assume that either the track was not fully cleared or conditions were not suitable for racing. The other missing record was due to a driver failing to complete a lap due to collision."
  },
  {
    "objectID": "stat244.html#data-visualization",
    "href": "stat244.html#data-visualization",
    "title": "STAT-244-SC",
    "section": "Data Visualization",
    "text": "Data Visualization\nOur response variable:pit_in\n\nNumber of pit stops for each lap \nDensity plot for lap time of each team  - A smaller lap time in Formula 1 means that the driver completed a lap more quickly. In racing, lower lap times are better because they indicate higher performance.\nBox plot of tire life for each compound  - The tire compound directly affects tire life, and the relationship is based on a trade-off between performance (speed/grip) and durability. Therefore, the softer the compound, the shorter the tire life.\nNumber of tires for each compound  - Since the tire life is shorter for the softer compounds, but has a better performance, the drivers preferred MEDIUM tire to balance the trade-off."
  },
  {
    "objectID": "stat244.html#research-questions",
    "href": "stat244.html#research-questions",
    "title": "STAT-244-SC",
    "section": "Research questions",
    "text": "Research questions\n\nWere drivers more likely to make pit stops when their lap time was longer and their tires were older compared to when their lap time was shorter and their tires were less used?\nWere drivers more likely to make pit stops when their lap times were longer, their tires were older, and considering the type of tires they were using and their progress in the race?\n\n\nLinear models considering based on the research question\n\nModel 1: \\[\n\\mathbb{E}(pit\\_in \\mid lap\\_time,\\ tyre\\_life) = \\beta_0 + \\beta_1(lap\\_time) + \\beta_2(tyre\\_life)\n\\]\nModel 2: \\[\n\\begin{aligned}\n\\mathbb{E}(pit\\_in \\mid lap\\_time, \\ lap\\_number, \\ compound, \\ tyre\\_life)  &= \\beta_0 + \\beta_1(lap\\_time) \\\\ &+ \\beta_2(lap\\_number) + \\beta_3(compound) \\\\ &+ \\beta_4(tyre\\_life)\n\\end{aligned}\n\\]\n\n\n# STEP 1: Model Specification\nlm_spec &lt;- linear_reg() %&gt;%\n  set_mode(\"regression\") %&gt;%\n  set_engine(\"lm\")\n\n# STEP 2: Model estimation\n# first linear model\npit_lm1 &lt;- lm_spec %&gt;%\n  fit(pit_in ~ lap_time + tyre_life, data = miami2024)\npit_lm1 %&gt;% tidy()\n\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept) -0.422    0.0543       -7.77 1.74e-14\n2 lap_time     0.00429  0.000537      7.98 3.63e-15\n3 tyre_life    0.00243  0.000509      4.79 1.94e- 6\n\n# second linear model\npit_lm2 &lt;- lm_spec %&gt;%\n  fit(pit_in ~ lap_time + lap_number + compound + tyre_life, data = miami2024)\npit_lm2 %&gt;% tidy()\n\n# A tibble: 6 × 5\n  term           estimate std.error statistic  p.value\n  &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)    -0.446    0.0544       -8.21 6.32e-16\n2 lap_time        0.00468  0.000534      8.76 7.32e-18\n3 lap_number     -0.00214  0.000387     -5.54 3.88e- 8\n4 compoundMEDIUM  0.0117   0.00936       1.25 2.10e- 1\n5 compoundSOFT    0.0312   0.0240        1.30 1.93e- 1\n6 tyre_life       0.00519  0.000698      7.44 1.97e-13"
  },
  {
    "objectID": "stat244.html#cross-validation",
    "href": "stat244.html#cross-validation",
    "title": "STAT-244-SC",
    "section": "Cross Validation",
    "text": "Cross Validation\nCross-validation is a statistical method used to evaluate how well a model performs by splitting the data into multiple subsets to train the model on some subsets and validate it on the remaining subsets.\n\nGoal: Provide a more reliable and unbiased estimate of a model’s performance predicting new data, in order to detect overfitting and improve model generalization\n\n\nDividing data into test set and training set\n\nk-fold CV: We can use k-fold cross-validation to estimate the typical error in our model predictions for new data:\n\nDivide the data into \\(k\\) folds (or groups) of approximately equal size.\nRepeat the following procedures for each fold \\(j = 1,2,...,k\\):\n\nRemove fold \\(j\\) from the data set.\nFit a model using the data in the other \\(k-1\\) folds (training).\nUse this model to predict the responses for the \\(n_j\\) cases in fold \\(j\\): \\(\\hat{y}_1, ..., \\hat{y}_{n_j}\\).\nCalculate the MAE/MSE for fold \\(j\\) (testing):\n\nCombine this information into one measure of model quality\n\n\n\n\nError metric to use\n\nMean absolute error (MAE) of an estimator measures the absolute difference between the predicted values and the actual values in the dataset.\n\n\\(\\text{MAE}_j = \\frac{1}{n_j}\\sum_{i=1}^{n_j} |y_i - \\hat{y}_i|\\)\n\\(\\text{CV}_{(k)} = \\frac{1}{k} \\sum_{j=1}^k \\text{MAE}_j\\)\n\nMean squared error (MSE) of an estimator measures the average squared difference between the predicted values and the actual values in the dataset.\n\n\\(\\text{MSE}_j = \\frac{1}{n_j}\\sum_{i=1}^{n_j} (y_i - \\hat{y}_i)^2\\)\n\\(\\text{CV}_{(k)} = \\frac{1}{k} \\sum_{j=1}^k \\text{MSE}_j\\)\n\n\n\nMAE vs. MSE\nThe advantage of using MAE is that it’s more robust to outliers, giving equal weight to all errors. Thus, it’s more suitable when outliers are not a significant concern.\nOn the other hand, MSE gives more weight to larger errors than smaller ones, making it highly sensitive to outliers. MSE is more suitable when the risk of prediction mistakes is crucial and the goal is to minimize the risk of errors.\nSince outliers are less of a concern for us as they don’t lead to any life threatening or other major issues, we prioritize models that are directly interpretable. Our data is less common and less familiar to many people, so we decided to choose a model based on MAE.\n\npit_lm1 %&gt;% augment(new_data = miami2024) %&gt;%\n  mae(truth = pit_in, estimate = .pred)\n\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 mae     standard      0.0505\n\npit_lm2 %&gt;% augment(new_data = miami2024) %&gt;%\n  mae(truth = pit_in, estimate = .pred)\n\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 mae     standard      0.0587"
  },
  {
    "objectID": "stat244.html#k-fold-cv-implementation-for-different-values-of-k",
    "href": "stat244.html#k-fold-cv-implementation-for-different-values-of-k",
    "title": "STAT-244-SC",
    "section": "k-fold CV implementation for different values of k",
    "text": "k-fold CV implementation for different values of k\n\nk=5\nModel 1\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm1_k5 = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + tyre_life,\n    resamples = vfold_cv(miami2024, v = 5),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm1_k5 %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0507     5 0.00159 Preprocessor1_Model1\n2 rmse    standard   0.152      5 0.00536 Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm1_k5 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 5 × 7\n  splits            id    .metric .estimator .estimate .config          .notes  \n  &lt;list&gt;            &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;list&gt;  \n1 &lt;split [884/222]&gt; Fold1 mae     standard      0.0477 Preprocessor1_M… &lt;tibble&gt;\n2 &lt;split [885/221]&gt; Fold2 mae     standard      0.0560 Preprocessor1_M… &lt;tibble&gt;\n3 &lt;split [885/221]&gt; Fold3 mae     standard      0.0528 Preprocessor1_M… &lt;tibble&gt;\n4 &lt;split [885/221]&gt; Fold4 mae     standard      0.0486 Preprocessor1_M… &lt;tibble&gt;\n5 &lt;split [885/221]&gt; Fold5 mae     standard      0.0485 Preprocessor1_M… &lt;tibble&gt;\n\n\n\nBased on the random folds above, MAE was best for fold 1 (0.048) and worst for fold 2 (0.056).\n\nModel 2\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm2_k5 = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + lap_number + compound + tyre_life,\n    resamples = vfold_cv(miami2024, v = 5),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm2_k5 %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0592     5 0.00161 Preprocessor1_Model1\n2 rmse    standard   0.150      5 0.00490 Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm2_k5 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 5 × 7\n  splits            id    .metric .estimator .estimate .config          .notes  \n  &lt;list&gt;            &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;list&gt;  \n1 &lt;split [884/222]&gt; Fold1 mae     standard      0.0533 Preprocessor1_M… &lt;tibble&gt;\n2 &lt;split [885/221]&gt; Fold2 mae     standard      0.0621 Preprocessor1_M… &lt;tibble&gt;\n3 &lt;split [885/221]&gt; Fold3 mae     standard      0.0617 Preprocessor1_M… &lt;tibble&gt;\n4 &lt;split [885/221]&gt; Fold4 mae     standard      0.0585 Preprocessor1_M… &lt;tibble&gt;\n5 &lt;split [885/221]&gt; Fold5 mae     standard      0.0606 Preprocessor1_M… &lt;tibble&gt;\n\n\n\nBased on the random folds above, MAE was best for fold 1 (0.053) and worst for fold 2 (0.062).\n\n\n# 5-fold CV MAE and sd\npit_lm1_k5 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean      sd\n   &lt;dbl&gt;   &lt;dbl&gt;\n1 0.0507 0.00356\n\npit_lm2_k5 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean      sd\n   &lt;dbl&gt;   &lt;dbl&gt;\n1 0.0592 0.00360\n\n\nIn-sample and 5-fold CV MAE and standard deviation for both models.\n\n\n\n\n\n\n\n\n\n\n\nModel\nIn-sample MAE\n5-fold CV MAE\nIn-sample SD\n5-fold CV SD\n\n\n\n\nmodel_1\n0.05045\n0.05073\n0.15247\n0.00356\n\n\nmodel_2\n0.05975\n0.05922\n0.15035\n0.00360\n\n\n\n\n\nk=10\nModel 1\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm1_cv = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + tyre_life,\n    resamples = vfold_cv(miami2024, v = 10),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm1_cv %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0510    10 0.00294 Preprocessor1_Model1\n2 rmse    standard   0.150     10 0.0109  Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm1_cv %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 10 × 7\n   splits            id     .metric .estimator .estimate .config        .notes  \n   &lt;list&gt;            &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;          &lt;list&gt;  \n 1 &lt;split [995/111]&gt; Fold01 mae     standard      0.0368 Preprocessor1… &lt;tibble&gt;\n 2 &lt;split [995/111]&gt; Fold02 mae     standard      0.0544 Preprocessor1… &lt;tibble&gt;\n 3 &lt;split [995/111]&gt; Fold03 mae     standard      0.0614 Preprocessor1… &lt;tibble&gt;\n 4 &lt;split [995/111]&gt; Fold04 mae     standard      0.0472 Preprocessor1… &lt;tibble&gt;\n 5 &lt;split [995/111]&gt; Fold05 mae     standard      0.0379 Preprocessor1… &lt;tibble&gt;\n 6 &lt;split [995/111]&gt; Fold06 mae     standard      0.0602 Preprocessor1… &lt;tibble&gt;\n 7 &lt;split [996/110]&gt; Fold07 mae     standard      0.0600 Preprocessor1… &lt;tibble&gt;\n 8 &lt;split [996/110]&gt; Fold08 mae     standard      0.0434 Preprocessor1… &lt;tibble&gt;\n 9 &lt;split [996/110]&gt; Fold09 mae     standard      0.0505 Preprocessor1… &lt;tibble&gt;\n10 &lt;split [996/110]&gt; Fold10 mae     standard      0.0581 Preprocessor1… &lt;tibble&gt;\n\n\n\nBased on the random folds above, the MAE was best for fold 1 with an MAE of approximately 0.037 and worst for fold 3 with an MAE of 0.061 approximately.\n\nModel 2\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm2_cv = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + lap_number + compound + tyre_life,\n    resamples = vfold_cv(miami2024, v = 10),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm2_cv %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0594    10 0.00262 Preprocessor1_Model1\n2 rmse    standard   0.148     10 0.0104  Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm2_cv %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 10 × 7\n   splits            id     .metric .estimator .estimate .config        .notes  \n   &lt;list&gt;            &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;          &lt;list&gt;  \n 1 &lt;split [995/111]&gt; Fold01 mae     standard      0.0436 Preprocessor1… &lt;tibble&gt;\n 2 &lt;split [995/111]&gt; Fold02 mae     standard      0.0616 Preprocessor1… &lt;tibble&gt;\n 3 &lt;split [995/111]&gt; Fold03 mae     standard      0.0698 Preprocessor1… &lt;tibble&gt;\n 4 &lt;split [995/111]&gt; Fold04 mae     standard      0.0566 Preprocessor1… &lt;tibble&gt;\n 5 &lt;split [995/111]&gt; Fold05 mae     standard      0.0518 Preprocessor1… &lt;tibble&gt;\n 6 &lt;split [995/111]&gt; Fold06 mae     standard      0.0658 Preprocessor1… &lt;tibble&gt;\n 7 &lt;split [996/110]&gt; Fold07 mae     standard      0.0655 Preprocessor1… &lt;tibble&gt;\n 8 &lt;split [996/110]&gt; Fold08 mae     standard      0.0521 Preprocessor1… &lt;tibble&gt;\n 9 &lt;split [996/110]&gt; Fold09 mae     standard      0.0601 Preprocessor1… &lt;tibble&gt;\n10 &lt;split [996/110]&gt; Fold10 mae     standard      0.0671 Preprocessor1… &lt;tibble&gt;\n\n\n\nBased on the random folds above, MAE was best for fold 1 (0.044) and worst for fold 3 (0.070).\n\n\n# 10-fold CV MAE and sd\npit_lm1_cv %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean      sd\n   &lt;dbl&gt;   &lt;dbl&gt;\n1 0.0510 0.00931\n\npit_lm2_cv %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean      sd\n   &lt;dbl&gt;   &lt;dbl&gt;\n1 0.0594 0.00829\n\n\nIn-sample and 10-fold CV MAE and standard deviation for both models.\n\n\n\n\n\n\n\n\n\n\n\nModel\nIn-sample MAE\n10-fold CV MAE\nIn-sample SD\n10-fold CV SD\n\n\n\n\nmodel_1\n0.05045\n0.05100\n0.15247\n0.00931\n\n\nmodel_2\n0.05975\n0.05939\n0.15035\n0.00829\n\n\n\n\n\nk = 20\nModel 1\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm1_k20 = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + tyre_life,\n    resamples = vfold_cv(miami2024, v = 20),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm1_k20 %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0509    20 0.00399 Preprocessor1_Model1\n2 rmse    standard   0.140     20 0.0142  Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm1_k20 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 20 × 7\n   splits            id     .metric .estimator .estimate .config        .notes  \n   &lt;list&gt;            &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;          &lt;list&gt;  \n 1 &lt;split [1050/56]&gt; Fold01 mae     standard      0.0451 Preprocessor1… &lt;tibble&gt;\n 2 &lt;split [1050/56]&gt; Fold02 mae     standard      0.0519 Preprocessor1… &lt;tibble&gt;\n 3 &lt;split [1050/56]&gt; Fold03 mae     standard      0.0509 Preprocessor1… &lt;tibble&gt;\n 4 &lt;split [1050/56]&gt; Fold04 mae     standard      0.0658 Preprocessor1… &lt;tibble&gt;\n 5 &lt;split [1050/56]&gt; Fold05 mae     standard      0.0439 Preprocessor1… &lt;tibble&gt;\n 6 &lt;split [1050/56]&gt; Fold06 mae     standard      0.0412 Preprocessor1… &lt;tibble&gt;\n 7 &lt;split [1051/55]&gt; Fold07 mae     standard      0.0602 Preprocessor1… &lt;tibble&gt;\n 8 &lt;split [1051/55]&gt; Fold08 mae     standard      0.0429 Preprocessor1… &lt;tibble&gt;\n 9 &lt;split [1051/55]&gt; Fold09 mae     standard      0.0402 Preprocessor1… &lt;tibble&gt;\n10 &lt;split [1051/55]&gt; Fold10 mae     standard      0.0263 Preprocessor1… &lt;tibble&gt;\n11 &lt;split [1051/55]&gt; Fold11 mae     standard      0.0266 Preprocessor1… &lt;tibble&gt;\n12 &lt;split [1051/55]&gt; Fold12 mae     standard      0.0585 Preprocessor1… &lt;tibble&gt;\n13 &lt;split [1051/55]&gt; Fold13 mae     standard      0.0704 Preprocessor1… &lt;tibble&gt;\n14 &lt;split [1051/55]&gt; Fold14 mae     standard      0.0274 Preprocessor1… &lt;tibble&gt;\n15 &lt;split [1051/55]&gt; Fold15 mae     standard      0.0302 Preprocessor1… &lt;tibble&gt;\n16 &lt;split [1051/55]&gt; Fold16 mae     standard      0.0825 Preprocessor1… &lt;tibble&gt;\n17 &lt;split [1051/55]&gt; Fold17 mae     standard      0.0591 Preprocessor1… &lt;tibble&gt;\n18 &lt;split [1051/55]&gt; Fold18 mae     standard      0.0429 Preprocessor1… &lt;tibble&gt;\n19 &lt;split [1051/55]&gt; Fold19 mae     standard      0.0611 Preprocessor1… &lt;tibble&gt;\n20 &lt;split [1051/55]&gt; Fold20 mae     standard      0.0901 Preprocessor1… &lt;tibble&gt;\n\n\n\nBased on the random folds above, MAE was best for fold 10 (0.026) and worst for fold 20 (0.090).\n\nModel 2\n\n# set seed for reproducibility\nset.seed(123)\n\npit_lm2_k20 = lm_spec %&gt;%\n  fit_resamples(\n    pit_in ~ lap_time + lap_number + compound + tyre_life,\n    resamples = vfold_cv(miami2024, v = 20),\n    metrics = metric_set(mae, rmse)\n  )\npit_lm2_k20 %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator   mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.0593    20 0.00398 Preprocessor1_Model1\n2 rmse    standard   0.139     20 0.0134  Preprocessor1_Model1\n\n# get fold-by-fold results\npit_lm2_k20 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\")\n\n# A tibble: 20 × 7\n   splits            id     .metric .estimator .estimate .config        .notes  \n   &lt;list&gt;            &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;          &lt;list&gt;  \n 1 &lt;split [1050/56]&gt; Fold01 mae     standard      0.0508 Preprocessor1… &lt;tibble&gt;\n 2 &lt;split [1050/56]&gt; Fold02 mae     standard      0.0623 Preprocessor1… &lt;tibble&gt;\n 3 &lt;split [1050/56]&gt; Fold03 mae     standard      0.0564 Preprocessor1… &lt;tibble&gt;\n 4 &lt;split [1050/56]&gt; Fold04 mae     standard      0.0755 Preprocessor1… &lt;tibble&gt;\n 5 &lt;split [1050/56]&gt; Fold05 mae     standard      0.0596 Preprocessor1… &lt;tibble&gt;\n 6 &lt;split [1050/56]&gt; Fold06 mae     standard      0.0535 Preprocessor1… &lt;tibble&gt;\n 7 &lt;split [1051/55]&gt; Fold07 mae     standard      0.0652 Preprocessor1… &lt;tibble&gt;\n 8 &lt;split [1051/55]&gt; Fold08 mae     standard      0.0492 Preprocessor1… &lt;tibble&gt;\n 9 &lt;split [1051/55]&gt; Fold09 mae     standard      0.0474 Preprocessor1… &lt;tibble&gt;\n10 &lt;split [1051/55]&gt; Fold10 mae     standard      0.0324 Preprocessor1… &lt;tibble&gt;\n11 &lt;split [1051/55]&gt; Fold11 mae     standard      0.0347 Preprocessor1… &lt;tibble&gt;\n12 &lt;split [1051/55]&gt; Fold12 mae     standard      0.0630 Preprocessor1… &lt;tibble&gt;\n13 &lt;split [1051/55]&gt; Fold13 mae     standard      0.0818 Preprocessor1… &lt;tibble&gt;\n14 &lt;split [1051/55]&gt; Fold14 mae     standard      0.0362 Preprocessor1… &lt;tibble&gt;\n15 &lt;split [1051/55]&gt; Fold15 mae     standard      0.0405 Preprocessor1… &lt;tibble&gt;\n16 &lt;split [1051/55]&gt; Fold16 mae     standard      0.0838 Preprocessor1… &lt;tibble&gt;\n17 &lt;split [1051/55]&gt; Fold17 mae     standard      0.0652 Preprocessor1… &lt;tibble&gt;\n18 &lt;split [1051/55]&gt; Fold18 mae     standard      0.0537 Preprocessor1… &lt;tibble&gt;\n19 &lt;split [1051/55]&gt; Fold19 mae     standard      0.0724 Preprocessor1… &lt;tibble&gt;\n20 &lt;split [1051/55]&gt; Fold20 mae     standard      0.102  Preprocessor1… &lt;tibble&gt;\n\n\n\nBased on the random folds above, MAE was best for fold 10 (0.032) and worst for fold 20 (0.101).\n\n\n# 20-fold CV MAE and sd\npit_lm1_k20 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean     sd\n   &lt;dbl&gt;  &lt;dbl&gt;\n1 0.0509 0.0178\n\npit_lm2_k20 %&gt;% unnest(.metrics) %&gt;%\n  filter(.metric == \"mae\") %&gt;%\n  summarize(mean = mean(.estimate), sd = sd(.estimate))\n\n# A tibble: 1 × 2\n    mean     sd\n   &lt;dbl&gt;  &lt;dbl&gt;\n1 0.0593 0.0178\n\n\nIn-sample and 20-fold CV MAE and standard deviation for both models.\n\n\n\n\n\n\n\n\n\n\n\nModel\nIn-sample MAE\n20-fold CV MAE\nIn-sample SD\n20-fold CV SD\n\n\n\n\nmodel_1\n0.05045\n0.05086\n0.15247\n0.01785\n\n\nmodel_2\n0.05975\n0.05925\n0.15035\n0.01781\n\n\n\n\n\nCompare different values of k\n\n\n\n\n\n\n\n\n\n\n\nModel\nIn-sample MAE\n5-fold CV MAE\n10-fold CV MAE\n20-fold CV MAE\n\n\n\n\nmodel_1\n0.05045\n0.05073\n0.05100\n0.05086\n\n\nmodel_2\n0.05975\n0.05922\n0.05939\n0.05925"
  },
  {
    "objectID": "stat244.html#final-model-based-on-the-smallest-cv-error",
    "href": "stat244.html#final-model-based-on-the-smallest-cv-error",
    "title": "STAT-244-SC",
    "section": "Final model based on the smallest CV error",
    "text": "Final model based on the smallest CV error\nAll of the above results suggests model_1 is the better model than model_2.\nTherefore, our final model based on the smallest CV error is:\n\\[\n\\mathbb{E}(pit\\_in \\mid lap\\_time,\\ tyre\\_life) = \\beta_0 + \\beta_1(lap\\_time) + \\beta_2(tyre\\_life)\n\\]"
  },
  {
    "objectID": "stat244.html#variables-of-interest",
    "href": "stat244.html#variables-of-interest",
    "title": "STAT-244-SC",
    "section": "Variables of interest",
    "text": "Variables of interest\n\nPredictors\n\nlap_time: recorded time to complete a lap (seconds)\nlap_number: lap number from which the telemetry data was recorded (number of laps)\ntyre_life: number of laps completed on a set of tires (number of laps)\ncompound: type of tire used (SOFT, MEDIUM, HARD)\n\n\n\nResponse variable\n\npit_in: whether a driver made a pit stop during a lap (binary: 0 = no pit stop, 1 = pit stop occurred)\n\\[\\begin{align*}\nY_i &= \\begin{cases} 1 & \\text{ if a driver pitted on a lap } \\\\ 0 & \\text{ otherwise (i.e., the driver did not pit on lap)} \\end{cases}\n\\end{align*}\\]"
  },
  {
    "objectID": "stat244.html#our-logistic-regression-model",
    "href": "stat244.html#our-logistic-regression-model",
    "title": "STAT-244-SC",
    "section": "Our logistic regression model",
    "text": "Our logistic regression model\nWe are interested in determining the probability of making a pit stop during the 2024 Miami Grand Prix, considering factors such as lap time, track progress, tire age, and the type of tire used.\n\\[\n\\begin{aligned}\n\\log(odds(pit\\_in \\mid lap\\_time, \\ lap\\_number, \\ tyre\\_life, \\ compound)) &= \\beta_0 + \\beta_1 (lap\\_time) \\\\ &+ \\beta_2(lap\\_number) + \\beta_3 (tyre\\_life) \\\\ &+ \\beta_4 \\ I(compound = MEDIUM) \\\\ &+ \\beta_5 \\ I(compound = SOFT)\n\\end{aligned}\n\\]\n\n# factor `pit_in` for logistic regression analysis\nmiami2024_glm &lt;- miami2024 %&gt;%\n  mutate(pit_in_fac = as.factor(pit_in))\n\n\n# logistic regression model\nlogistic_fit &lt;- train(\n  form   = pit_in_fac ~ lap_time + lap_number + tyre_life + compound,\n  data   = miami2024_glm,\n  family = \"binomial\", # this is an argument to glm; response is 0 or 1, binomial\n  method = \"glm\",      # method for fit; \"generalized linear model\"\n  trControl = trainControl(method = \"none\")\n)\n\nsummary(logistic_fit$finalModel)\n\n\nCall:\nNULL\n\nCoefficients:\n                Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)    -18.48162    2.27137  -8.137 4.06e-16 ***\nlap_time         0.13739    0.02007   6.846 7.58e-12 ***\nlap_number      -0.16001    0.03630  -4.408 1.04e-05 ***\ntyre_life        0.27508    0.04580   6.006 1.91e-09 ***\ncompoundMEDIUM   0.49495    0.49718   0.996    0.319    \ncompoundSOFT     1.86135    1.17923   1.578    0.114    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 261.16  on 1105  degrees of freedom\nResidual deviance: 176.46  on 1100  degrees of freedom\nAIC: 188.46\n\nNumber of Fisher Scoring iterations: 8\n\n\n\nInterpretation of exponentiated \\(\\hat{\\beta}\\) coefficients\n\nexp(logistic_fit$finalModel$coefficients)\n\n   (Intercept)       lap_time     lap_number      tyre_life compoundMEDIUM \n  9.408757e-09   1.147280e+00   8.521343e-01   1.316630e+00   1.640419e+00 \n  compoundSOFT \n  6.432386e+00 \n\n\n\n\\(\\exp(\\beta_0)\\): The odds of a driver making a pit stop during a lap, when lap time is 0 seconds, lap number is 0, 0 laps have been completed on the current set of tires, and the HARD compound is, is approximately \\(9.4088 \\times 10^{-9}\\).\n\\(\\exp(\\beta_1)\\): For every of 1 second increase in lap time, the odds of a driver pitting increase by a factor of 1.1473.\n\\(\\exp(\\beta_2)\\): For every additional lap (i.e., increase of 1 in the lap number), we expect the odds of a driver pitting to increase by a factor of 0.8521.\n\\(\\exp(\\beta_3)\\): For each additional lap completed on the current set of tires, the odds of a driver pitting increase by a factor of 1.3166.\n\\(\\exp(\\beta_4)\\): When using MEDIUM compound tires instead of HARD, the odds of a driver pitting increase by a factor of 1.6404, holding all other variables constant.\n\\(\\exp(\\beta_5)\\): When using SOFT compound tires instead of HARD, we expect the odds of a driver pitting to increase by a factor of 6.4324, holding all other variables constant.\n\n\nMathematically derive \\(\\exp(\\beta_1)\\)\n\\[\n\\begin{aligned}\n&\\log(odds(pit\\_in \\mid lap\\_time = a)) = -18.4816 + 0.1374a\n\\\\\n\\\\\n&\\log(odds(pit\\_in \\mid lap\\_time = a+1)) = -18.4816 + 0.1374(a+1)\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n& \\log\\left( \\frac{odds(pit\\_in \\mid lap\\_time = a+1)}{odds(pit\\_in \\mid lap\\_time = a)} \\right)\\\\\n&= \\log(odds(pit\\_in \\mid lap\\_time = a+1)) - \\log(odds(pit\\_in \\mid lap\\_time = a)) \\\\\n&= (-18.4816 + 0.1374(a+1)) - (-18.4816 + 0.1374) \\\\\n&= 0.1374  \\\\\n&= \\hat{\\beta_1}\n\\end{aligned}\n\\]\nTherefore, \\(\\exp(\\beta_1) = e^{0.1374} = 1.1473\\)\n\n\n\nPredicting High Probability of a Pit Stop\nTo predict a probability of a driver making a pit stop that is very close to 1, we need to input extreme values for the predictors. Based on the five-number summary of our data, we use the following scenario: a lap time of 148.74 seconds, lap number 57, SOFT compound, and a tire age of 45 laps.\n\n# miami2024_glm %&gt;% \n#   ggplot(aes(x=lap_time)) +\n#     geom_density(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.8)\n\nsummary(miami2024_glm)\n\n    lap_time        lap_number      compound     tyre_life    \n Min.   : 90.63   Min.   : 1.00   HARD  :500   Min.   : 1.00  \n 1st Qu.: 92.38   1st Qu.:14.00   MEDIUM:562   1st Qu.: 7.00  \n Median : 93.28   Median :28.00   SOFT  : 44   Median :13.50  \n Mean   : 96.00   Mean   :28.62                Mean   :14.78  \n 3rd Qu.: 94.29   3rd Qu.:43.00                3rd Qu.:22.00  \n Max.   :148.74   Max.   :57.00                Max.   :45.00  \n     pit_in        pit_in_fac\n Min.   :0.00000   0:1078    \n 1st Qu.:0.00000   1:  28    \n Median :0.00000             \n Mean   :0.02532             \n 3rd Qu.:0.00000             \n Max.   :1.00000             \n\n\n\nlog_prid_fst &lt;- predict(logistic_fit$finalModel,\n            newdata = data.frame(lap_time = 148.74,\n                                 lap_number = 57,\n                                 tyre_life = 45,\n                                 compoundMEDIUM = 0,\n                                 compoundSOFT = 1),\n            type = \"response\")\n    \nodds_pitting_fst = exp(log_prid_fst)\n(prob_pitting_fst = odds_pitting_fst/(1+odds_pitting_fst))\n\n        1 \n0.7308921 \n\n\nUsing our logistic regression model, we estimate the probability of a pit stop under these conditions to be approximately 0.731. This indicates a high likelihood of a pit stop given these extreme race conditions.\n\n\nPredicting Pit Stops with our Logistic Regression Model\n\nEstimate the probability of a driver making a pit stop on a lap with the following conditions: 96.00 seconds lap time, 28th lap, 14.78 laps completed on a set of HARD tires.\n\nlog_prid_hard &lt;- predict(logistic_fit$finalModel,\n        newdata = data.frame(lap_time = 96,\n                             lap_number = 28,\n                             tyre_life = 14.78,\n                             compoundMEDIUM = 0,\n                             compoundSOFT = 0),\n        type = \"response\")\n\nodds_pitting_hard = exp(log_prid_hard)\n(prob_pitting_hard = odds_pitting_hard/(1+odds_pitting_hard))\n\n        1 \n0.5008283 \n\n\n\nThere is approximately a 50.08% probability that a driver will make a pit stop on this lap when using HARD tires, holding all other variables constant.\n\n\nEstimate the probability of a driver making a pit stop on a lap under the same conditions as above but using a set of MEDIUM tires.\n\nlog_prid_med &lt;- predict(logistic_fit$finalModel,\n        newdata = data.frame(lap_time = 96,\n                             lap_number = 28,\n                             tyre_life = 14.78,\n                             compoundMEDIUM = 1,\n                             compoundSOFT = 0),\n        type = \"response\")\n\nodds_pitting_med = exp(log_prid_med)\n(prob_pitting_med = odds_pitting_med/(1+odds_pitting_med))\n\n        1 \n0.5013559 \n\n\n\nWith MEDIUM tires, the probability of making a pit stop increases to 50.14%.\n\n\nEstimate the probability of a driver making a pit stop on a lap under the same conditions as above but using a set of SOFT tires.\n\nlog_prid_soft &lt;- predict(logistic_fit$finalModel,\n        newdata = data.frame(lap_time = 96,\n                             lap_number = 28,\n                             tyre_life = 14.78,\n                             compoundMEDIUM = 0,\n                             compoundSOFT = 1),\n        type = \"response\")\n\nodds_pitting_soft = exp(log_prid_soft)\n(prob_pitting_soft = odds_pitting_soft/(1+odds_pitting_soft))\n\n        1 \n0.5052337 \n\n\n\nWith SOFT tires, the probability increases slightly to 50.52%.\nWhile all the other variables stay the same, we predict that the probability a driver to made a pit stop is higher if the driver is on a set of SOFT tires compared to other compounds."
  },
  {
    "objectID": "stat244.html#proscons-of-logistic-regression-vs.-regular-linear-regression",
    "href": "stat244.html#proscons-of-logistic-regression-vs.-regular-linear-regression",
    "title": "STAT-244-SC",
    "section": "Pros/Cons of logistic regression vs. regular linear regression",
    "text": "Pros/Cons of logistic regression vs. regular linear regression\n\nLogistic Regression\n\n\n\n\n\n\n\nPros\nSince logistic regression is based on a Bernoulli/binomial likelihood, it is a natural model for binary outcomes.\nCoefficients are interpretable in terms of odds ratios (with log-odds as the linear predictor).\n\n\nCons\nThe relationship between predictors and the probability is not linear.\n\n\n\n\n\nLinear Regression\n\n\n\n\n\n\n\nPros\nStraightforward linear regression\nEasy to interpret the coefficients\n\n\nCons\nCannot gaurantee that the predicted probabilities to be between 0 and 1."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! My name is Yerim\nI am a senior at Mount Holyoke College. I am interested in machine learning and statistics!\n \n\n\nCareer Objectives\nDetail-oriented Statistics major (expected May 2025) with hands-on experience in data modeling, research, and statistical analysis. Proficient in statistical software, including R, Python, and Excel, with proven ability to manage and analyze complex datasets, develop computational models, and lead collaborative projects. Committed to applying statistical knowledge to real-world problems and contributing to data-driven solutions. Seeking an entry-level role in data analysis to leverage technical and analytical skills and support the success of a dynamic team.\n\n\nData Analysis & Modeling\n\nRegression\nSurvey Sampling\nMachine Learning\nStatistical Modeling\n\n\n\nTechnical Skills"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HOME",
    "section": "",
    "text": "This is Yerim’s website for STAT-244SC"
  }
]